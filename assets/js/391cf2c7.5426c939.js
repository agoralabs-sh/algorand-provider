"use strict";(self.webpackChunk_agoralabs_sh_algorand_provider=self.webpackChunk_agoralabs_sh_algorand_provider||[]).push([[210],{9840:(a,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>g,default:()=>y,frontMatter:()=>d,metadata:()=>u,toc:()=>p});var e=t(7462),s=t(3366),o=(t(7294),t(3905)),r=t(4866),i=t(5162),l=t(3901),c=["components"],d={},g="Signing Transactions",u={unversionedId:"getting-started/dapps/signing-transactions",id:"getting-started/dapps/signing-transactions",title:"Signing Transactions",description:"<TOCInline",source:"@site/docs/getting-started/dapps/signing-transactions.mdx",sourceDirName:"getting-started/dapps",slug:"/getting-started/dapps/signing-transactions",permalink:"/getting-started/dapps/signing-transactions",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Enabling A Wallet",permalink:"/getting-started/dapps/enabling-a-wallet"},next:{title:"Sending Transactions",permalink:"/getting-started/dapps/sending-transactions"}},m={},p=[{value:"Overview",id:"overview",level:2},{value:"Signing a single transaction",id:"signing-a-single-transaction",level:2},{value:"Signing atomic transactions",id:"signing-atomic-transactions",level:2},{value:"Non-wallet signed transactions",id:"non-wallet-signed-transactions",level:3},{value:"Signing transactions with multisig accounts",id:"signing-transactions-with-multisig-accounts",level:2},{value:"Signing transactions with re-keyed accounts",id:"signing-transactions-with-re-keyed-accounts",level:2}],T={toc:p},h="wrapper";function y(a){var n=a.components,t=(0,s.Z)(a,c);return(0,o.kt)(h,(0,e.Z)({},T,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"signing-transactions"},"Signing Transactions"),(0,o.kt)(l.Z,{maxHeadingLevel:4,toc:p,mdxType:"TOCInline"}),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"Wallets, if supported can sign single, atomic or multiple transactions. If the wallet also supports it, the wallet can also sign transactions using multisigs and re-keyed accounts."),(0,o.kt)("h2",{id:"signing-a-single-transaction"},"Signing a single transaction"),(0,o.kt)("p",null,"Regardless of whether you are sending multiple transactions or a single transaction, an array of base64 encoded transactions will need to be sent."),(0,o.kt)(r.Z,{defaultValue:"javascript",values:[{label:"Javascript",value:"javascript"},{label:"TypeScript",value:"typescript"}],mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"javascript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  base64ToBytes,\n  bytesToBase64,\n  IBaseResult,\n  ISignTxnsResult,\n} = require('@agoralabs-sh/algorand-provider');\nconst algosdk = require('algosdk');\n\ntry {\n  const encoder = new TextEncoder();\n  const client = new algosdk.Algodv2(\n    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n    'http://localhost',\n    '4001',\n  );\n  const suggestedParams = await client.getTransactionParams().do();\n  const transaction = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n    amount: algosdk.algosToMicroalgos(1),\n    from: 'P3AIQVDJ2CTH54KSJE63YWB7IZGS4W4JGC53I6GK72BGZ5BXO2B2PS4M4U',\n    note: encoder.encode('Hello Human!'),\n    suggestedParams,\n    to: '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ',\n  });\n  const transactionBytes = transaction.toByte();\n  const result = await window.algorand.signTxns({\n    txns: [\n      {\n        txn: bytesToBase64(transactionBytes),\n      },\n    ],\n  });\n  let signedTransactionBytes;\n\n  console.log(result);\n  /*\n  {\n    id: 'awesome-wallet',\n    stxns: [\n      'gqNzaWfEQ...',\n    ],\n  }\n  */\n\n  // decode the base 64 encoded signed transactions\n  signedTransactionBytes = base64ToBytes(result.stxns[0]);\n\n  // send to the network\n  await client.sendRawTransaction(signedTransactionBytes).do();\n} catch (error) {\n  // handle error\n}\n"))),(0,o.kt)(i.Z,{value:"typescript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import {\n  base64ToBytes,\n  bytesToBase64,\n  IBaseResult,\n  ISignTxnsResult,\n} from '@agoralabs-sh/algorand-provider';\nimport {\n  algosToMicroalgos,\n  Algodv2,\n  makePaymentTxnWithSuggestedParamsFromObject,\n  SuggestedParams,\n  Transaction,\n} from 'algosdk';\n\ntry {\n  const encoder: TextEncoder = new TextEncoder();\n  const client: Algodv2 = new Algodv2(\n    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n    'http://localhost',\n    '4001',\n  );\n  const suggestedParams: SuggestedParams = await client.getTransactionParams().do();\n  const transaction: Transaction = makePaymentTxnWithSuggestedParamsFromObject({\n    amount: algosToMicroalgos(1),\n    from: 'P3AIQVDJ2CTH54KSJE63YWB7IZGS4W4JGC53I6GK72BGZ5BXO2B2PS4M4U',\n    note: encoder.encode('Hello Human!'),\n    suggestedParams,\n    to: '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ',\n  });\n  const transactionBytes: Uint8Array = transaction.toByte();\n  const result: IBaseResult & ISignTxnsResult = await window.algorand.signTxns({\n    txns: [\n      {\n        txn: bytesToBase64(transactionBytes),\n      },\n    ],\n  });\n  let signedTransactionBytes: Uint8Array;\n\n  console.log(result);\n  /*\n  {\n    id: 'awesome-wallet',\n    stxns: [\n      'gqNzaWfEQ...',\n    ],\n  }\n  */\n\n  // decode the base 64 encoded signed transactions\n  signedTransactionBytes = base64ToBytes(result.stxns[0]);\n\n  // send to the network\n  await client.sendRawTransaction(signedTransactionBytes).do();\n} catch (error) {\n  // handle error\n}\n")))),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"If this operation is not supported, then a ",(0,o.kt)("a",{parentName:"p",href:"../../api-reference/errors#walletoperationnotsupportederror"},(0,o.kt)("inlineCode",{parentName:"a"},"WalletOperationNotSupportedError"))," will be thrown.")),(0,o.kt)("h2",{id:"signing-atomic-transactions"},"Signing atomic transactions"),(0,o.kt)("p",null,"When sending atomic transactions, all transactions, regardless of whether the wallet is signing only some of the transactions, must be sent with a matching group ID."),(0,o.kt)(r.Z,{defaultValue:"javascript",values:[{label:"Javascript",value:"javascript"},{label:"TypeScript",value:"typescript"}],mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"javascript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  base64ToBytes,\n  bytesToBase64,\n  IBaseResult,\n  ISignTxnsResult,\n} = require('@agoralabs-sh/algorand-provider');\nconst algosdk = require('algosdk');\n\ntry {\n  const encoder = new TextEncoder();\n  const client = new algosdk.Algodv2(\n    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n    'http://localhost',\n    '4001',\n  );\n  const suggestedParams = await client.getTransactionParams().do();\n  const firstTransaction = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n    amount: algosdk.algosToMicroalgos(1),\n    from: 'P3AIQVDJ2CTH54KSJE63YWB7IZGS4W4JGC53I6GK72BGZ5BXO2B2PS4M4U',\n    note: encoder.encode('I am the first transaction, human!'),\n    suggestedParams,\n    to: '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ',\n  });\n  const secondTransaction = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n    amount: algosdk.algosToMicroalgos(2),\n    from: 'P3AIQVDJ2CTH54KSJE63YWB7IZGS4W4JGC53I6GK72BGZ5BXO2B2PS4M4U',\n    note: encoder.encode('I am the second transaction, human!'),\n    suggestedParams,\n    to: '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ',\n  });\n  let firstTransactionBytes;\n  let result;\n  let secondTransactionBytes;\n  let signedTransactionBytes;\n\n  // assign a group id\n  algosdk.assignGroupID([firstTransaction, secondTransaction]);\n\n  firstTransactionBytes = firstTransaction.toByte();\n  secondTransactionBytes = secondTransaction.toByte();\n\n  // send to the wallet to be signed\n  result = await window.algorand.signTxns({\n    txns: [\n      {\n        txn: bytesToBase64(firstTransactionBytes),\n      },\n      {\n        txn: bytesToBase64(secondTransactionBytes),\n      },\n    ],\n  });\n\n  console.log(result);\n  /*\n  {\n    id: 'awesome-wallet',\n    stxns: [\n      'gqNzaWfEQ...',\n      'gqNzaWfEQ...',\n    ],\n  }\n  */\n\n  // decode the base 64 encoded signed transactions\n  signedTransactionBytes = result.stxns.map((value) => base64ToBytes(value));\n\n  // send to the network\n  await client.sendRawTransaction(signedTransactionBytes).do();\n} catch (error) {\n  // handle error\n}\n"))),(0,o.kt)(i.Z,{value:"typescript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import {\n  base64ToBytes,\n  bytesToBase64,\n  IBaseResult,\n  ISignTxnsResult,\n} from '@agoralabs-sh/algorand-provider';\nimport {\n  algosToMicroalgos,\n  Algodv2,\n  assignGroupID,\n  makePaymentTxnWithSuggestedParamsFromObject,\n  SuggestedParams,\n  Transaction,\n} from 'algosdk';\n\ntry {\n  const encoder: TextEncoder = new TextEncoder();\n  const client: Algodv2 = new Algodv2(\n    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n    'http://localhost',\n    '4001',\n  );\n  const suggestedParams: SuggestedParams = await client.getTransactionParams().do();\n  const firstTransaction: Transaction = makePaymentTxnWithSuggestedParamsFromObject({\n    amount: algosToMicroalgos(1),\n    from: 'P3AIQVDJ2CTH54KSJE63YWB7IZGS4W4JGC53I6GK72BGZ5BXO2B2PS4M4U',\n    note: encoder.encode('I am the first transaction, human!'),\n    suggestedParams,\n    to: '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ',\n  });\n  const secondTransaction: Transaction = makePaymentTxnWithSuggestedParamsFromObject({\n    amount: algosToMicroalgos(2),\n    from: 'P3AIQVDJ2CTH54KSJE63YWB7IZGS4W4JGC53I6GK72BGZ5BXO2B2PS4M4U',\n    note: encoder.encode('I am the second transaction, human!'),\n    suggestedParams,\n    to: '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ',\n  });\n  const transactionBytes: Uint8Array = transaction.toByte();\n  let firstTransactionBytes: Uint8Array;\n  let result: IBaseResult & ISignTxnsResult;\n  let secondTransactionBytes: Uint8Array;\n  let signedTransactionBytes: Uint8Array[];\n\n  // assign a group id\n  assignGroupID([firstTransaction, secondTransaction]);\n\n  firstTransactionBytes = firstTransaction.toByte();\n  secondTransactionBytes = secondTransaction.toByte();\n\n  // send to the wallet to be signed\n  result = await window.algorand.signTxns({\n    txns: [\n      {\n        txn: bytesToBase64(firstTransactionBytes),\n      },\n      {\n        txn: bytesToBase64(secondTransactionBytes),\n      },\n    ],\n  });\n\n  console.log(result);\n  /*\n  {\n    id: 'awesome-wallet',\n    stxns: [\n      'gqNzaWfEQ...',\n      'gqNzaWfEQ...',\n    ],\n  }\n  */\n\n  // decode the base 64 encoded signed transactions\n  signedTransactionBytes = result.stxns.map((value) => base64ToBytes(value));\n\n  // send to the network\n  await client.sendRawTransaction(signedTransactionBytes).do();\n} catch (error) {\n  // handle error\n}\n")))),(0,o.kt)("h3",{id:"non-wallet-signed-transactions"},"Non-wallet signed transactions"),(0,o.kt)("p",null,"In the case of a wallet being sent an atomic transaction, but only needing to sign a subset of the transactions, an empty ",(0,o.kt)("inlineCode",{parentName:"p"},"signers")," array must be used. This instructs the wallet to skip the transaction even if it can sign it."),(0,o.kt)("p",null,"For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const result = await window.algorand.signTxns({\n  txns: [\n    {\n      txn: 'iqNhbXRko...',\n    },\n    {\n      signers: [], // an empty array instructs the wallet to skip signing this transaction\n      txn: 'iaRhZnJ6w...',\n    },\n  ],\n});\n\nconsole.log(result);\n/*\n{\n  id: 'awesome-wallet',\n  stxns: [\n    'gqNzaWfEQ...',\n    null,\n  ],\n}\n*/\n\n")),(0,o.kt)("p",null,"As you can see from the above example, when the wallet skips signing that transaction, the resulting signed transaction list contains ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," where the transactions were not signed. In order to avoid this, you can supply the signed transaction (",(0,o.kt)("inlineCode",{parentName:"p"},"stxn"),") to the options object, when signing the transactions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const result = await window.algorand.signTxns({\n  txns: [\n    {\n      txn: 'iqNhbXRko...',\n    },\n    {\n      signers: [], // an empty array instructs the wallet to skip signing this transaction\n      stxn: 'gqNzaWfEQ...', // providing the signed transaction will pass it to the result\n      txn: 'iaRhZnJ6w...',\n    },\n  ],\n});\n\nconsole.log(result);\n/*\n{\n  id: 'awesome-wallet',\n  stxns: [\n    'gqNzaWfEQ...',\n    'gqNzaWfEQ...'\n  ],\n}\n*/\n")),(0,o.kt)("h2",{id:"signing-transactions-with-multisig-accounts"},"Signing transactions with multisig accounts"),(0,o.kt)("p",null,"When using multisig accounts to sign transactions, a few extra options must be provided to the options object."),(0,o.kt)("p",null,"The transaction must now include the ",(0,o.kt)("inlineCode",{parentName:"p"},"msig")," object that conforms to ",(0,o.kt)("a",{parentName:"p",href:"https://algorand.github.io/js-algorand-sdk/interfaces/MultisigMetadata.html"},(0,o.kt)("inlineCode",{parentName:"a"},"algosdk.MultisigMetadata")),"."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"The wallet may not support multisig accounts, in which case a ",(0,o.kt)("a",{parentName:"p",href:"../../api-reference/errors#walletoperationnotsupportederror"},(0,o.kt)("inlineCode",{parentName:"a"},"WalletOperationNotSupportedError"))," will be thrown.")),(0,o.kt)(r.Z,{defaultValue:"javascript",values:[{label:"Javascript",value:"javascript"},{label:"TypeScript",value:"typescript"}],mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"javascript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  base64ToBytes,\n  bytesToBase64,\n  IBaseResult,\n  ISignTxnsResult,\n} = require('@agoralabs-sh/algorand-provider');\nconst algosdk = require('algosdk');\n\ntry {\n  const encoder = new TextEncoder();\n  const client = new algosdk.Algodv2(\n    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n    'http://localhost',\n    '4001',\n  );\n  const multisigParams = {\n    addrs: [\n      'P3AIQVDJ2CTH54KSJE63YWB7IZGS4W4JGC53I6GK72BGZ5BXO2B2PS4M4U', // authorized in wallet and will be used to sign\n      '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ', // authorized in wallet and will be used to sign\n      'TKDBCV4SCSVR2GECXL7NJ5U34PDNLEIMFBTOYVURAPG53OXJLF4LEDSNGE', // not in wallet\n    ],\n    threshold: 1,\n    version: 1,\n  };\n  const multisigAddress = algosdk.multisigAddress(multisigParams);\n  const suggestedParams = await client.getTransactionParams().do();\n  const transaction = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n    amount: algosdk.algosToMicroalgos(1),\n    from: multisigAddress,\n    note: encoder.encode('Hello Human!'),\n    suggestedParams,\n    to: '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ',\n  });\n  const transactionBytes = transaction.toByte();\n  const result = await window.algorand.signTxns({\n    txns: [\n      {\n        msig: multisigParams,\n        txn: bytesToBase64(transactionBytes),\n      },\n    ],\n  });\n  let signedTransactionBytes;\n\n  console.log(result);\n  /*\n  {\n    id: 'awesome-wallet',\n    stxns: [\n      'gqNzaWfEQ...',\n    ],\n  }\n  */\n\n  // decode the base 64 encoded signed transaction\n  signedTransactionBytes = base64ToBytes(result.stxns[0]);\n\n  // send to the network\n  await client.sendRawTransaction(signedTransactionBytes).do();\n} catch (error) {\n  // handle error\n}\n"))),(0,o.kt)(i.Z,{value:"typescript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import {\n  base64ToBytes,\n  bytesToBase64,\n  IBaseResult,\n  ISignTxnsResult,\n} from '@agoralabs-sh/algorand-provider';\nimport {\n  algosToMicroalgos,\n  Algodv2,\n  makePaymentTxnWithSuggestedParamsFromObject,\n  MultisigMetadata,\n  multisigAddress,\n  SuggestedParams,\n  Transaction,\n} from 'algosdk';\n\ntry {\n  const encoder: TextEncoder = new TextEncoder();\n  const client: Algodv2 = new Algodv2(\n    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n    'http://localhost',\n    '4001',\n  );\n  const multisigParams: MultisigMetadata = {\n    addrs: [\n      'P3AIQVDJ2CTH54KSJE63YWB7IZGS4W4JGC53I6GK72BGZ5BXO2B2PS4M4U', // authorized in wallet and will be used to sign\n      '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ', // authorized in wallet and will be used to sign\n      'TKDBCV4SCSVR2GECXL7NJ5U34PDNLEIMFBTOYVURAPG53OXJLF4LEDSNGE', // not in wallet\n    ],\n    threshold: 1,\n    version: 1,\n  };\n  const multisigAddress: string = multisigAddress(multisigParams);\n  const suggestedParams: SuggestedParams = await client.getTransactionParams().do();\n  const transaction: Transaction = makePaymentTxnWithSuggestedParamsFromObject({\n    amount: algosToMicroalgos(1),\n    from: multisigAddress,\n    note: encoder.encode('Hello Human!'),\n    suggestedParams,\n    to: '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ',\n  });\n  const transactionBytes: Uint8Array = transaction.toByte();\n  const result: IBaseResult & ISignTxnsResult = await window.algorand.signTxns({\n    txns: [\n      {\n        msig: multisigParams,\n        txn: bytesToBase64(transactionBytes),\n      },\n    ],\n  });\n  let signedTransactionBytes: Uint8Array;\n\n  console.log(result);\n  /*\n  {\n    id: 'awesome-wallet',\n    stxns: [\n      'gqNzaWfEQ...',\n    ],\n  }\n  */\n\n  // decode the base 64 encoded signed transaction\n  signedTransactionBytes = base64ToBytes(result.stxns[0]);\n\n  // send to the network\n  await client.sendRawTransaction(signedTransactionBytes).do();\n} catch (error) {\n  // handle error\n}\n")))),(0,o.kt)("p",null,"In the above example, even though the threshold is 1, because two of the signers are present and authorized in the wallet, both accounts were used to sign the transaction. This still makes the transaction valid."),(0,o.kt)("p",null,"If you want to only use one address, you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"signers")," list to instruct the wallet to only use certain addresses to sign the transaction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const multisigParams = {\n    addrs: [\n      'P3AIQVDJ2CTH54KSJE63YWB7IZGS4W4JGC53I6GK72BGZ5BXO2B2PS4M4U', // authorized in wallet, but will not be used to sign\n      '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ', // authorized in wallet, will be used to sign\n      'TKDBCV4SCSVR2GECXL7NJ5U34PDNLEIMFBTOYVURAPG53OXJLF4LEDSNGE', // not in wallet\n    ],\n    threshold: 1,\n    version: 1,\n  };\nconst result = await window.algorand.signTxns({\n  txns: [\n    {\n      msig: multisigParams,\n      signers: [\n        '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ'\n      ], // specifying a signer instructs the wallet to only use this address to sign\n      txn: 'iaRhZnJ6w...',\n    },\n  ],\n});\n\nconsole.log(result);\n/*\n{\n  id: 'awesome-wallet',\n  stxns: [\n    'gqNzaWfEQ...',\n  ],\n}\n*/\n")),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"If any of the accounts supplied in the ",(0,o.kt)("inlineCode",{parentName:"p"},"signers")," list are not an authorized signer, then a ",(0,o.kt)("a",{parentName:"p",href:"../../api-reference/errors#unauthorizedsignererror"},(0,o.kt)("inlineCode",{parentName:"a"},"UnauthorizedSignerError"))," will be thrown.")),(0,o.kt)("p",null,"Now, in the above example, only the address ",(0,o.kt)("inlineCode",{parentName:"p"},"6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ")," is used to sign the transaction and as the threshold is only 1, the transaction is valid."),(0,o.kt)("h2",{id:"signing-transactions-with-re-keyed-accounts"},"Signing transactions with re-keyed accounts"),(0,o.kt)("p",null,"When attempting to sign a transaction using a re-keyed account, the ",(0,o.kt)("inlineCode",{parentName:"p"},"authAddr")," field may be used to instruct the wallet to use as the signer of the transaction. Supplying the ",(0,o.kt)("inlineCode",{parentName:"p"},"authAddr")," will override the sender address of the transaction field."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"The wallet may not support re-keyed accounts, in which case a ",(0,o.kt)("a",{parentName:"p",href:"../../api-reference/errors#walletoperationnotsupportederror"},(0,o.kt)("inlineCode",{parentName:"a"},"WalletOperationNotSupportedError"))," will be thrown.")),(0,o.kt)(r.Z,{defaultValue:"javascript",values:[{label:"Javascript",value:"javascript"},{label:"TypeScript",value:"typescript"}],mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"javascript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  base64ToBytes,\n  bytesToBase64,\n  IBaseResult,\n  ISignTxnsResult,\n} = require('@agoralabs-sh/algorand-provider');\nconst algosdk = require('algosdk');\n\ntry {\n  const encoder = new TextEncoder();\n  const client = new algosdk.Algodv2(\n    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n    'http://localhost',\n    '4001',\n  );\n  const suggestedParams = await client.getTransactionParams().do();\n  const transaction = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n    amount: algosdk.algosToMicroalgos(1),\n    from: 'P3AIQVDJ2CTH54KSJE63YWB7IZGS4W4JGC53I6GK72BGZ5BXO2B2PS4M4U', // the re-keyed account\n    note: encoder.encode('Hello Human!'),\n    suggestedParams,\n    to: '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ',\n  });\n  const transactionBytes = transaction.toByte();\n  const result = await window.algorand.signTxns({\n    txns: [\n      {\n        authAddr: 'S6V2ITXD3Q4MYATTN5IH75E3KS3WEMB36SVG2LXCQ3XESSH2DYOC3DAXYU', // 'auth-addr' of the re-keyed account\n        txn: bytesToBase64(transactionBytes),\n      },\n    ],\n  });\n  let signedTransactionBytes;\n\n  console.log(result);\n  /*\n  {\n    id: 'awesome-wallet',\n    stxns: [\n      'gqNzaWfEQ...',\n    ],\n  }\n  */\n\n  // decode the base 64 encoded signed transactions\n  signedTransactionBytes = base64ToBytes(result.stxns[0]);\n\n  // send to the network\n  await client.sendRawTransaction(signedTransactionBytes).do();\n} catch (error) {\n  // handle error\n}\n"))),(0,o.kt)(i.Z,{value:"typescript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import {\n  base64ToBytes,\n  bytesToBase64,\n  IBaseResult,\n  ISignTxnsResult,\n} from '@agoralabs-sh/algorand-provider';\n  import {\n  algosToMicroalgos,\n  Algodv2,\n  makePaymentTxnWithSuggestedParamsFromObject,\n  SuggestedParams,\n  Transaction,\n} from 'algosdk';\n\ntry {\n  const encoder: TextEncoder = new TextEncoder();\n  const client: Algodv2 = new Algodv2(\n    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n    'http://localhost',\n    '4001',\n  );\n  const suggestedParams: SuggestedParams = await client.getTransactionParams().do();\n  const transaction: Transaction = makePaymentTxnWithSuggestedParamsFromObject({\n    amount: algosToMicroalgos(1),\n    from: 'P3AIQVDJ2CTH54KSJE63YWB7IZGS4W4JGC53I6GK72BGZ5BXO2B2PS4M4U', // the re-keyed account\n    note: encoder.encode('Hello Human!'),\n    suggestedParams,\n    to: '6GT6EXFDAHZDZYUOPT725ZRWYBZDCEGYT7SYYXGJKRFUAG5B7JMI7DQRNQ',\n  });\n  const transactionBytes: Uint8Array = transaction.toByte();\n  const result: IBaseResult & ISignTxnsResult = await window.algorand.signTxns({\n    txns: [\n      {\n        authAddr: 'S6V2ITXD3Q4MYATTN5IH75E3KS3WEMB36SVG2LXCQ3XESSH2DYOC3DAXYU', // 'auth-addr' of the re-keyed account\n        txn: bytesToBase64(transactionBytes),\n      },\n    ],\n  });\n  let signedTransactionBytes: Uint8Array;\n\n  console.log(result);\n  /*\n  {\n    id: 'awesome-wallet',\n    stxns: [\n      'gqNzaWfEQ...',\n    ],\n  }\n  */\n\n  // decode the base 64 encoded signed transaction\n  signedTransactionBytes = base64ToBytes(result.stxns[0]);\n\n  // send to the network\n  await client.sendRawTransaction(signedTransactionBytes).do();\n} catch (error) {\n  // handle error\n}\n")))),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"If the supplied ",(0,o.kt)("inlineCode",{parentName:"p"},"authAddr")," is not an authorized signer, then a ",(0,o.kt)("a",{parentName:"p",href:"../../api-reference/errors#unauthorizedsignererror"},(0,o.kt)("inlineCode",{parentName:"a"},"UnauthorizedSignerError"))," will be thrown.")))}y.isMDXComponent=!0}}]);